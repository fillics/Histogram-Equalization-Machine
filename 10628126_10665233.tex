\documentclass[12pt, table, xcdraw]{article}

\usepackage{amsmath}
\usepackage[toc,page,header]{appendix}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{placeins}

\usetikzlibrary{arrows,automata}

\renewcommand*\contentsname{Indice}

\title{PROVA FINALE DI RETI LOGICHE}
\date{Prof. William Fornaciari - AA: 2020/2021}
\author{Filippo Caliò (907675) - Cod.Persona: 10628126 \\ Giovanni Caleffi (907455) - Cod.Persona: 10665233}


\begin{document}

\maketitle
\pagenumbering{gobble}
\tableofcontents

\newpage
\pagenumbering{arabic}

\section{Introduzione}

\subsection{Scopo del progetto}
Lo scopo del progetto è la realizzazione di un componente hardware, scritto in VHDL. Esso riceve in ingresso un'immagine in scala di grigi a 256 livelli e, dopo aver applicato un algoritmo di equalizzazione a ciascun pixel, scrive in output l'immagine equalizzata.\\
Di seguito, un esempio di un'immagine 2x2 equalizzata (l'indirizzo dei dati in memoria verrà spiegato nel paragrafo 1.4).

\begin{table}[h!]
  \begin{center}
    \
	\begin{tabular}{cccccccccc}
	0                                                        & 1                                                       & 2                                               & 3                                                & 4                                               & 5                                               & 6                                              & 7                                                & 8                                               & 9                                                \\ \hline
	\rowcolor[HTML]{EFEFEF} 
	\multicolumn{1}{|c|}{\cellcolor[HTML]{EFEFEF}\textbf{2}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{2}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}46} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}131} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}62} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}89} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}0} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}255} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}64} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}172} \\ \hline
	\end{tabular}

  
  \end{center}
\end{table}


\subsection{Specifiche generali}
L'algoritmo usato per l'equalizzazione delle immagini è una versione semplificata rispetto all'algoritmo standard. Esso può essere applicato solo a immagini in scala di grigi e per trasformare ogni pixel dell'immagine, esegue le seguenti operazioni:

\begin{center}

\textsc{delta\_value = max\_pixel\_value – min\_pixel\_value} \\
\textsc{shift\_level = (8 – floor(log2(delta\_value + 1)))} \\
\textsc{temp\_pixel = (current\_pixel\_value - min\_pixel\_value) \textless\textless  shift\_level} \\
\textsc{new\_pixel\_value = min(255 , temp\_pixel)} \\
\end{center}

\textsc{max\_pixel\_value} e \textsc{min\_pixel\_value} rappresentano rispettivamente il massimo e il minimo valore dei pixel dell'immagine, \textsc{current\_pixel\_value} rappresenta il valore del pixel da trasformare e \textsc{new\_pixel\_value} rappresenta il valore del nuovo pixel in output. \\

Il componente hardware è inoltre progettato per poter codificare più immagini, una dopo l'altra. Prima di codificare l'immagine successiva, però, l'algoritmo di equalizzazione deve essere stato applicato prima a tutti i pixel dell'immagine precedente.

\newpage

\subsection{Interfaccia del componente}
L’interfaccia del componente, così come presentata nelle specifiche, è la seguente:

\begin{tabbing}
entity \= project\_reti\_logiche is \\
	\> port $($ \= \\
		\>\> i\_clk : in std\_logic; \\
		\>\> i\_rst : in std\_logic; \\
		\>\> i\_start : in std\_logic; \\ 
		\>\> i\_data : in std\_logic\_vector (7 downto 0); \\ 
		\>\> o\_address : out std\_logic\_vector (15 downto 0); \\ 
		\>\> o\_done : out std\_logic; \\
		\>\> o\_en : out std\_logic; \\ 
		\>\> o\_we : out std\_logic; \\ 
		\>\> o\_data : out std\_logic\_vector (7 downto 0) \\
	\>$)$; \\
end project\_reti\_logiche; \\

\end{tabbing}
In particolare:
\begin{itemize}
\item \texttt{i\_clk}: segnale di CLOCK in ingresso generato dal TestBench;
\item \texttt{i\_rst}: segnale di RESET che inizializza la macchina pronta per ricevere il primo
segnale di START;
\item \texttt{i\_start}: segnale di START generato dal Test Bench;
\item \texttt{i\_data}: segnale (vettore) che arriva dalla memoria in seguito ad una richiesta di
lettura;
\item \texttt{o\_address}: segnale (vettore) di uscita che manda l’indirizzo alla memoria;
\item \texttt{o\_done}: segnale di uscita che comunica la fine dell’elaborazione e il dato di uscita
scritto in memoria;
\item \texttt{o\_en}: segnale di ENABLE da dover mandare alla memoria per poter comunicare
(sia in lettura che in scrittura);
\item \texttt{o\_we}: segnale di WRITE ENABLE da dover mandare alla memoria (=1) per poter
scriverci. Per leggere da memoria esso deve essere 0;
\item \texttt{o\_data}: segnale (vettore) di uscita dal componente verso la memoria.


\end{itemize}



\subsection{Dati e descrizione memoria}

Le dimensioni dell'immagine, ciascuna di dimensione di 8 bit, sono memorizzati in una memoria con indirizzamento al Byte:
\begin{itemize}
\item Nell'indirizzo 0 viene salvato il numero di colonne \textsc{(n-col)} dell'immagine.
\item Nell'indirizzo 1 viene salvato il numero di righe \textsc{(n-rig)} dell'immagine.
\item A partire dall'indirizzo 2 vengono memorizzati i pixel dell'immagine, ciascuno di 8 bit.
\item A partire dall'indirizzo \textsc{2+(n-col*n-rig)} vengono memorizzati i pixel dell'immagine equalizzata.


\end{itemize}


\begin{table}[h!]
\begin{center}
\begin{tabular}{|
>{\columncolor[HTML]{EFEFEF}}c |clll}
\cline{1-1}
\textbf{N\_COLONNE} & \multicolumn{4}{c}{Indirizzo 0}                     \\ \cline{1-1}
\textbf{N\_RIGHE}   & \multicolumn{4}{c}{Indirizzo 1}                     \\ \cline{1-1}
PIXEL\_1            & \multicolumn{4}{c}{Indirizzo 2}                     \\ \cline{1-1}
...                 & \multicolumn{4}{l}{}                                \\ \cline{1-1}
PIXEL\_N            & \multicolumn{4}{c}{}                                \\ \cline{1-1}
NEW\_PIXEL\_1       & \multicolumn{4}{c}{Indirizzo  \textsc{2+(n-col*n-rig)}}   \\ \cline{1-1}
...                 & \multicolumn{4}{c}{...}                             \\ \cline{1-1}
NEW\_PIXEL\_N       & \multicolumn{4}{c}{Indirizzo  \textsc{1+2*(n-col*n-rig)}} \\ \cline{1-1}
\end{tabular}
\end{center}
\end{table}

La dimensione massima dell'immagine è 128x128 pixel. 


\section{Design e scelte progettuali}
La macchina è pensata per lege\\
La macchina è composta da 18 stati. Qui di seguito è fornita una descrizione dei vari processi.
\newpage
\newenvironment{changemargin}[2]{%
\begin{list}{}{%
\setlength{\topsep}{0 pt}%
\setlength{\leftmargin}{#1}%
\setlength{\rightmargin}{#2}%
\setlength{\listparindent}{\parindent}%
\setlength{\itemindent}{\parindent}%
\setlength{\parsep}{\parskip}%
}%
\item[]}{\end{list}}
\begin{changemargin}{-3cm}{-1cm}

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
        scale = 1,transform shape]

  \node[state,initial] (S0) {$S0$};
  \node[state] (S1) [right of=S0] {$S1$};
  \node[state] (S2) [right of=S1] {$S2$};
  \node[state] (S3) [right of=S2] {$S3$};
 \node[state] (S1xN) [below of=S3,  yshift = -1.5cm] {$S1xN$};
  \node[state] (S1x1) [left of=S1xN, xshift = -2cm] {$S1x1$};
  \node[state] (S4) [right of=S1xN] {$S4$};
  \node[state] (S5) [right of=S4, xshift = 1cm] {$S5$};
  \node[state] (S6) [below of=S5] {$S6$};
  \node[state] (S7) [below of=S1xN] {$S7$};
  \node[state] (S8) [below of=S7] {$S8$};
  \node[state] (S9) [right of=S8] {$S9$};
  \node[state] (S10) [right of=S9] {$S10$};
  \node[state] (S11) [below of=S10] {$S11$};
  \node[state] (S12) [below of=S11] {$S12$};
  \node[state] (S13) [left of=S12] {$S13$};
  \node[state] (S14) [above of=S13] {$S14$};
  \node[state] (S_FINAL) [left of=S13, xshift = -8.97cm] {$S\_FINAL$};
 

\path (S0) edge              node {$$} (S1)
        (S1) edge              node {$$} (S2)
        (S2) edge              node {$$} (S3)
        (S3) edge              node {$tabella$ $NxN$} (S4)
        (S3) edge  [left, pos = 0.4]            node {$tabella$ $1x1$} (S1x1)
        (S3) edge   [left, pos = 0.8]        node {$tabella$ $1xN$} (S1xN)
        (S4) edge  [below]            node {$fine$  $colonna$} (S5)
        (S5) edge              node {$$} (S6)
        (S6) edge              node {$$} (S4)
        (S4) edge              node {$fine$ $pixel$} (S7)
        (S1x1) edge              node {$$} (S7)
        (S1xN) edge              node {$$} (S7)
        (S7) edge              node {$$} (S8)
        (S8) edge              node {$$} (S9)
        (S9) edge              node {$$} (S10)
        (S10) edge              node {$$} (S11)
        (S11) edge              node {$$} (S12)
        (S12) edge              node {$$} (S13)
        (S13) edge  [left]            node {$o\_end\_contatore = '0'$} (S14)
        (S13) edge  [left , below]            node {$o\_end\_contatore = '1'$} (S_FINAL)
        (S14) edge              node {$$} (S11)
        (S4) edge  [loop above, pos=.6, right=2pt]            node {$lettura$ $pixel$} (S4)
			(S1xN) edge   [loop right]              node {$$} (S7)
			(S_FINAL) edge node {$$} (S0);


\end{tikzpicture}
\end{changemargin}


\subsection{Gestione dell'\texttt{o\_address}, dell'\texttt{enable}, dell'\texttt{o\_done} e del caricamento di \texttt{o\_data}:}

Specificare che l'oaddress è uguale a mux definitivo che se uguale a 0 prende il valore di mux roaddr e se uguale a 1 prende il valore di new o roAddr, usando il segnale di mux definitivo sel.

\begin{figure}[h!]
  \includegraphics[width=\linewidth]{addr1.jpg}
   \includegraphics[width=\linewidth]{addr2.jpg}

\end{figure}
\FloatBarrier
\newpage
\begin{itemize}
\item S0: caricamento nel registro \texttt{o\_roAddr} dedl valore iniziale di \texttt{o\_address} ("0000000000000000").
\item S1-S2-S3-S\_1xN-S4: incremento il valore di \texttt{o\_roAddr} per leggere tutti i valori in memoria.
\item S5-S\_1x1: il valore dell'\texttt{o\_address} smette di incrementare (necessario per il processo di gestione di righe e colonne).
\item S6: ricomincia l'incremento di \texttt{o\_address}.
\item S7: caricamento nel registro \texttt{new\_dim} dell'ultimo valore di \texttt{o\_address} che indica quanti elementi sono stati letti in memoria nel primo ciclo. Reset dell'\texttt{o\_address} e di \texttt{o\_roAddr} al valore iniziale.
\item S8: caricamento del valore del registro \texttt{new\_dim} all'interno del registro contatore, mentre il secondo ciclo dedicato all'equalizzazione dei pixel inizia, ricominciando a incrementare il valore di \texttt{o\_roAddr}.
\item S9: caricamento in \texttt{new\_o\_roAddr} del valore di \texttt{new\_dim} e \texttt{o\_roAddr} continua a incrementare.
\item S10: l'\texttt{o\_address} prende il valore \texttt{new\_o\_roAddr} che ora vale \texttt{new\_dim+1} e smette di seguire \texttt{o\_roAddr}. Nel frattempo il valore di \texttt{o\_roAddr} continua a incrementare.
\item S11: \texttt{new\_o\_roAddr} e \texttt{contatore} eseguono la stessa funzione dello stato precedente, tuttavia \texttt{o\_roAddr} si ferma al valore che aveva in S10.
\item S12: i 3 registri si comportano allo stesso modo di S11, ma in questo stato viene caricato in memoria il valore equalizzato di un pixel ponendo \texttt{o\_we} \textless = '1'.
\item S13: decremento il valore di \texttt{contatore} di 1, ricomincio a incrementare \texttt{o\_roAddr} e \texttt{new\_o\_roAddr} facendo in modo che però \texttt{o\_address} ora segua \texttt{o\_roAddr}.
\item S14: \texttt{o\_roAddr} e \texttt{new\_o\_roAddr} non si incrementano più e ora \texttt{o\_address} segue \texttt{new\_o\_roAddr}. Si ferma anche valore di \texttt{contatore}.
\item S\_FINAL: pongo \texttt{o\_done} \textless = '1' e \texttt{o\_en} \textless = '0' e la macchina termina.
\end{itemize}


\newpage
\subsection{Lettura dei pixel}
Processo per la gestione del ciclo dedicato alla lettura di tutti i pixel tramite l'uso del numero di righe e colonne:

\begin{figure}[h!]
  \includegraphics[width=\linewidth]{righecolonne.jpg}

\end{figure}
\FloatBarrier

\begin{itemize}
\item S1: viene scritto il numero di colonne all'interno del registro \texttt{o\_colonneIn} (registro che poi non verrà più modificato e utile per la gestione del secondo ciclo)
\item S2: viene scritto il numero di righe all'interno del registro \texttt{o\_righeIn} (registro che poi non verrà più modificato e utile per la gestione del secondo ciclo). Inoltre viene caricato nel registro \texttt{o\_colonneAgg} il valore di \texttt{o\_colonneIn} (registro che salva un valore e, quando necessario, decrementa il valore di 1). 
\item S3: viene caricato nel registro \texttt{o\_righeAgg} il valore di \texttt{o\_righeIn} (registro che salva un valore e, quando necessario, decrementa il valore di 1).
\item S1xN: stato che decrementa di 1 il valore di \texttt{o\_righeAgg} (tramite \texttt{sub\_righe}), ponendo a 1 \texttt{righeAgg\_sel}.
\item S4: stato di loop che per ogni ciclo di clock decrementa di 1 il valore di \texttt{o\_colonneAgg} (tramite \texttt{sub\_colonne}), ponendo a 1 \texttt{colonneAgg\_sel}. 
\item S5: stato che riporta il valore di \texttt{o\_colonneAgg} al valore iniziale contenuto in \texttt{o\_colonneIn} e nel frattempo decrementa di 1 il valore di \texttt{o\_righeAgg} (tramite \texttt{sub\_righe}), ponendo a 1 \texttt{righeAgg\_sel}.
\item S6: stato che riporta il valore di \texttt{o\_colonneAgg} al valore iniziale contenuto in \texttt{o\_colonneIn}.
\end{itemize}

\newpage
\subsection{Calcolo \textsc{max\_pixel\_value} e \textsc{min\_pixel\_value} e applicazione algoritmo per calcolare \textsc{new\_pixel\_value}}
Processo dedicato alla determinazione del pixel con valore massimo e minimo, del delta\_value e dello shift\_level e del nuovo valore del pixel




\begin{figure}[h!]
\hspace*{-1.1in}
  \includegraphics[width=.7\textwidth]{pixel.jpg}
 \includegraphics[width=.7\textwidth]{shiftlevel.jpg}

\end{figure}



\begin{figure}[b!]
  \includegraphics[width=.8\textwidth]{odata.jpg}
  \caption{Gestione o\_address}
  \label{fig:boat1}
\end{figure}
\FloatBarrier

\begin{itemize}
\item S3: salva il valore del primo pixel in \texttt{o\_pixelIn}, \texttt{o\_pixelMax}, mentre in \texttt{o\_pixelMin} viene caricato il valore 255.
\item S1x1: stato di eccezione quando la tabella contiene un solo pixel, viene salvato il valore di quel pixel in \texttt{o\_pixelMin}.
\item S4-S5-S6-S7-S\_1xN: stati in cui vengono letti tutti i pixel di una colonna e viene verificato quale sia il pixel con valore massimo e minimo.
\item S8: carica nel registro \texttt{delta\_value} la differenza tra i valori finali di \texttt{o\_pixelMax} e \texttt{o\_pixelMin} e carica il valore di \texttt{i\_data} in \texttt{o\_pixelIn}.
\item S9: carica il valore di \texttt{i\_data} in \texttt{o\_pixelIn}.
\item S10: parte il secondo ciclo e inserisco il primo valore della tabella nel registro \texttt{o\_current\_pixel\_value} e salvo nel registro \texttt{shift\_level}
la differenza tra 8 e il valore di \texttt{o\_floor}.
\item S14: stato che per ogni ciclo carica il valore di un pixel nel registro \texttt{o\_current\_pixel\_value}.
\end{itemize}

\newpage
\section{Risultati sperimentali}
\subsection{Report di sintesi}
\subsection{Simulazioni}
. test bench 1 (cosa fa e perchè lo fa e cosa verifica; per esempio,
controlla una condizione limite)
ii. test bench 2 (....)

\newpage
\section{Conclusioni}
Nel progettare il componente hardware, abbiamo prestato particolare attenzione nel rimuovere tutti i latch presenti.


\end{document}
